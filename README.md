
 # Informatik Projekt von Jannik und Thorge
 
 ## Inhaltsverzeichnis

1. [Projektseite](https://github.com/ThorgeHamprecht/Informatik-Projekt-Nr.-1/blob/main/2D%20Puzzle%20Game.md)
2. [ToDo-Liste](#ToDo)
3. [Stundenprotokoll](#prot)
4. [Arbeitsmethoden](#Methoden)
5. [Reflexion des Projekts](#Reflex)
6. [Quellen](#Quellen)
7. [Spiel - Snap! Community Site](https://snap.berkeley.edu/project?user=faiture&project=2D%20Puzzle%20Game)

  
 
 ## :heavy_check_mark:ToDo-Liste<a name="ToDo"></a>
 
Hier wird von nun an ([Mittwoch, 4. August](#zwei)) eine ToDo-Liste geführt, in der wir unsere Ziele und Fortschritte auf einen Blick sehen können.<br> 
Wir erhoffen uns damit mehr Übersicht während dieses Projekts zu behalten. Die ToDo-Liste wird aktuell gehalten werden und alte Beiträge werden der Übersichtlichkeit halber gelöscht. Gelöschte Beiträge finden sich aber in unserem Protokoll in dem Eintrag an ihrem Erstellungstag wieder.
 
- [x] *Anleitung Updaten*
- [x] *Fehler Beheben*
- [x] *Repository fertigstellen*
 
 
 ## :ledger:Stundenprotokoll<a name="prot"></a>
 
 <details>
<summary>Übersicht: Alle Einträge</summary>
<br>
 <table>
  <tr>
    <td><a href=#eins>Dienstag, 3. August</a></td>
    <td><a href=#zwei>Mittwoch, 4. August</a></td>
    <td><a href=#drei>Dienstag, 10. August</a></td>
    <td><a href=#vier>Mittwoch, 11. August</a></td>
    <td><a href=#fünf>Dienstag, 24. August</a></td>
  </tr>
  <tr>
    <td><a href=#sechs>Mittwoch, 25. August</a></td>
    <td><a href=#sieben>Dienstag, 31. August</a></td>
    <td><a href=#acht>Mittwoch, 1. September</a></td>
    <td><a href=#neun>Diesntag, 7. September</a></td>
    <td><a href=#zehn>Mittwoch, 8. September</a></td>
  </tr>
  <tr>
    <td><a href=#Ausfall1>Dienstag, 14. September</a></td>
    <td><a href=#Ausfall2>Mittwoch, 15. September</a></td>
    <td><a href=#elf>Mittwoch, 21. September</a></td>
    <td><a href=#zwölf>Mittwoch, 22. September</a></td>
    <td><a href=#dreizehn>Dienstag, 28. September</a></td>
  </tr>
  <tr>
    <td><a href=#Ausfall3>Mittwoch, 29. September</a></td>
    <td><a href=#vierzehn>Dienstag, 5. Oktober</a></td>
    <td><a href=#fünfzehn>Mittwoch, 6. Oktober</a></td>
    <td><a href=#sechzehn>Dienstag, 12. Oktober</a></td>
    <td><a href=#siebzehn>Mittwoch, 13. Oktober</a></td>
  </tr>
  <tr>
    <td><a href=#achtzehn>Dienstag. 19. Oktober</a></td>
    <td><a href=#neunzehn>Mittwoch, 20. Oktober</a></td>
    <td><a href=#zwanzig>Dienstag, 26. Oktober</a></td>
    <td><a href=#einundzwanzig>Mittwoch, 27. Oktober</a></td>
    <td><a href=#zweiundzwanzig>Dienstag, 2. November</a></td>
  </tr>
  <tr>
    <td><a href=#dreiundzwanzig>Mittwoch, 3. November</a></td>
    <td><a href=#Ausfall4>Dienstag, 9. November</a></td>
    <td><a href=#vierundzwanzig>Mittwoch, 10. November</a></td>
    <td><a href=#fünfundzwanzig>Dienstag, 16. November</a></td>
    <td><a href=#sechsundzwanzig>Mittwoch, 17. November</a></td>
  </tr>
  <tr>
    <td><a href=#siebenundzwanzig>Dienstag, 23. November</a></td>
    <td><a href=#achtundzwanzig>Mittwoch, 24. November</a></td>
    <td><a href=#neunundzwanzig>Dienstag, 30. November</a></td>
    <td><a href=#dreißig>Mittwoch, 1. Dezember</a></td>
    <td></td>
  </tr>
</table>
 
</details>

 
 ### Dienstag, 3. August<a name="eins"></a> 
 
Zunächst haben wir unseren GitHub Account erstellt. Danach haben wir dieses Repository ertsellt und uns über erste Möglichkeiten zur Bearbeitung auf GitHub anhand des Codes Ihres [*GitHub Repositorys*](https://github.com/jbuhl/InformatikUnterricht) informiert. Anschließend begann unser erstes Brainstorming zur Wahl eines Projekts. Dabei haben wir zunächst an die Entwicklung eines kleinen Spiels gedacht wollten anschließend jedoch lieber eine App entwicklen, da diese in unseren Augen langlebiger ist und nicht nur eine Art Gimick, dass einmal verwendung findet und danach überflüssig ist. Unsere erste Idee war eine App mit deren Hilfe man seinen Kleiderschrank digital katalogisieren kann. Dabei wollten wir unter anderem das einspeichern von outfits, sowie einen Überblick über Kleidungsstücke, die sich zurzeit in der Wäsche befinden implementieren.

### Mittwoch, 4. August<a name="zwei"></a>

Heute haben wir uns weiter mit Markdown und unserem GitHub Directory beschäftigt. Dabei haben wir gelernt, wie man Dropdowns einfügt:

```html
 <details>
    <summary>Zusammenfassung des Dropdowns</summary>
    <br>
     Hier gehören die Details und der weitere Inhalt hin.
    </details>
```
  
 Wie wir leider feststellen mussten, funktionieren eingebettete Links in Dropdowns nach normaler Markdown schreibweise nicht:<br>
 ` [Dienstag, 3. August](#eins)` Deshalb mussten wir stattdessen [*HTML*](https://de.wikipedia.org/wiki/Hypertext_Markup_Language) verwenden. Der Code hierfür war durch eine Recherche allerdings schnell zu finden: 
      
```html
<a href=HierDenLinkEinfügen>HierDenNamenEinfügen</a>
``` 
  
Im Verlauf der Stunde haben wir uns auch das Einbetten von Code in unser Directory angeiegnet.
  
Außerdem haben wir uns angeschaut, wie man einen Ordner in seinem Repository anlegt und Dateien in diesem speichert. Wir haben hier nun zur Demonstration ein Bild hochgeladen und in unser Repository eingefügt.
  
![Level 1 Stage -1](https://user-images.githubusercontent.com/88385813/144760115-b372ea5e-c7e0-49f1-ae80-68f4c26f47fa.png)

Um unsere Arbeit besser Überblicken zu können, haben wir folgendermaßen eine [**ToDo-Liste**](#ToDo) in unser Repository eingefügt:
      
    - [x] *Eine **ToDo-Liste** in unser Repository einfügen*
    - [x] *Mehr Struktur in unser Protokoll bringen*
    - [ ] *Umsetzbarkeit unserer App prüfen*
    - [ ] *Ersten Prototyp unseres Projekts anfertigen*
      
- [x] *Eine **ToDo-Liste** in unser Repository einfügen*
- [x] *Mehr Struktur in unser Protokoll bringen*
- [ ] *Umsetzbarkeit unserer App prüfen*
- [ ] *Ersten Prototyp unseres Projekts anfertigen*

### Dienstag, 10. August<a name="drei"></a> 

**Findung des geeigneten Programms zum Programmieren unserer App**

Sollten wir unsere App mit Swift programmieren?

Pro| Contra
------------ | -------------
• vermutlich "einfach" zu bedienen | • die App wird nicht auf Android funktionieren
• Apple-Design grafisch ansprechend | • eventuelle Online-Verfügbarkeit muss geprüft werden

Nach der letzten Stunde haben wir uns Zuhause nochn ein paar Gedanken über unsere App gemacht, dabei wollen wir nun eine ausschließliche IOS App mit [*XCode*](https://apps.apple.com/de/app/xcode/id497799835?mt=12) entwickeln. Wir haben uns für dieses Tool entschieden, da es einerseits die Programmiersprache [*Swift*](https://www.apple.com/de/swift/) beinhaltet, die auf das Programm abgestimmt sowie sehr anfängerfreundlich ist. Außerdem ist *XCode* ein First Party Tool und unterstützt damit alle Features der *IOS-Entwicklung*. Des weiteren wollen wir die App nur für eine Plattform entwicklen, um uns auf den wesentlichen Inhalt und nicht das Optimieren fokussieren zu müssen.

Hier ein kleines Beispiel zum reskalieren von Bildern. Somit kann man eine Art Collage in seinem Repository einfügen.
Der Code dafür sieht folgendermaßen aus:

```html
    <img src="Link zum Bild" alt="Bezeichnung" width="höhe" height="breite">
```
    
<img src="https://user-images.githubusercontent.com/88385813/144759942-9629147f-c3b7-49f3-a7f2-692b571f7180.png" alt="BlauerAbenteurer" width="214" height="360"> <img src="https://user-images.githubusercontent.com/88385813/144759961-e15d70df-9f8d-4365-ac09-a8a48c8872fa.png" alt="GrünerAbenteurer" width="214" height="360">


### Dienstag, 10. August<a name="drei"></a> 

In den letzen Tagen haben wir viel über unsere Projektidee des digitalen Kleiderschrankes nachgedacht. Wir sind zu dem Entschluss gekommen, das wir nicht weiter an dem Projekt des digitalen Kleiderschrankes festhalten wollen. Der hauptsächliche Grund stellt das Einscannen der Kleiderstücke dar. Man bräuchte zu große Datenmengen, damit jeder seine Kleidungsstücke digitalisieren kann. 
Aus diesem Grund hat die heutige Stunde für uns mit einem Brainstorming begonnen. Wir sind zu dem Entschluss gekommen, dass wir beide gerne ein Spiel entwerfen würden, das man zweidimensional spielen kann. Dabei sind uns zunächst zwei Ideen gekommen:
Die eine Möglichkeit stellt ein Spiel, nach dem Grundgedanken des Spiels "Subwaysurfers" da. Hierbei muss man einen Charakter nach links, rechts, oben oder unten bewegen, um Hindernissen auszuweichen. Schafft man dies nicht, muss man einen Lauf von Vorne beginnen. 
Eine andere Möglichkeit stellt ein Rätsel-Spiel da. Hierbei muss man mit einem Charakter Aufgaben z.B. in Form von Fragen lösen, um beispielsweise Türen zu öffnen oder um den Ausweg aus einem Labyrinth zu schaffen.
Wir haben uns nun entschieden diese beiden Gedanken zu kombinieren:
Wir möchten ein Spiel entwickeln, bei dem man einen Charakter zweidimensional von links nach rechts sowie von oben nach unten steuern kann. Dabei sollen dann Aufgaben gelöst werden, um weiter die Zielrichtung rechts zu erreichen. Über die genaue Art der Aufgaben haben wir uns bisher noch keine Gedanken gemacht.
Durch die neue Idee des Projekts haben wir uns auch überlegt, welches Programm wir benutzen wollen. Dabei sind wir auf [*Unity*](https://unity.com/de) gestoßen und haben nun vor mit der Programmiersprache [*C#*](https://de.wikipedia.org/wiki/C-Sharp) zu programmieren.
Aus diesem Grund haben wir das Programm [*Unity*](https://unity.com/de) heruntergeladen. 

![Unity](images/UnityScreenshot.png)

In diesem Screenshot aus der Engine [*Unity*](https://unity.com/de) kann man die Anfänge unseres Projekts sehen. Unser genaues vorgehen wird mithilfe der folgenden Bilder erklärt.

![VsStudio](images/VisualStudioScreenshot.png)

Mit [Microsoft Visual Studio](https://visualstudio.microsoft.com/de/) bearbeiten wir den Code in [*C#*](https://de.wikipedia.org/wiki/C-Sharp), der für die einzelnen Scripts benötigt wird. 


### Mittwoch, 11. August<a name="vier"></a>

Da die Stunde ausfiel haben wir uns ein paar Schritte überlegt, die wir als nächstes angehen wollen:
- [ ] *Musik für das Spiel erstellen*
- [ ] *Animationen erstellen*
- [ ] *Texturen erstellen*
- [x] *natürliche Level erstellen*

### Dienstag, 24. August<a name="fünf"></a>

Nachdem wir unseren Spieler in der letzten Stunde kontrollierbar gemacht haben, arbeiteten wir an den Animationen für unseren Spieler. Dabei ist wichtig, dass die einzelenen Animationen in den richtigen Momenten abgespielt werden. Dafür benutzen wir Unitys integrierten Animation-Controller, der es einem vereinfacht den Code und die Animationen zu verbinden. Im Code werden hierbei bei bestimmten Ereignissen bestimmte Animationen getriggert. Das Animieren selber ist derzeit über Keyframes sehr einfach durchzuführen. Da es sich bei unseren Sprites derzeit aber nur um Platzhalter handelt, werden diese später ausgetauscht.


### Mittwoch, 25. August<a name="sechs"></a>

Heute haben wir uns mit Ihnen über unsere Projektidee ausgetauscht. Sie äußerten das Bedenken, dass wir in C# programmieren. Außerdem müssen wir für Sie deutlich machen, welchen Teil des Codes wir selbst programmiert haben und welchen Teil des Codes schon in der Engine intergriert ist oder durch PlugIns hinzugefügt wurde. 
Anschließend haben wir weiter an dem Level-Aufbau gearbeitet.

### Dienstag, 31.08.2021 <a name="sieben"></a>

Nach dem Gespräch mit Ihnenn sind wir zu dem Entschluss gekommen, dass wir nicht an dem Programmieren in Unity mit der Programmiersprache C# festhalten wollen. Wir wollen nun mit [Snap!](https://snap.berkeley.edu/) arbeiten. Zuhause haben wir uns bereits mit der Realisierung unseres Projektes mit dem Programm Snap beschäftigt. Durch die vereinfachte Blockprogrammiersprache sind einige Dinge, wie z.B. eine realistische Physik, etwas schwieriger umzusetzten.
Wir haben damit angefangen einen provisorischen Spieler in Form eines Pfeils mit rudimetärer Bewegung nach links und rechts einzufügen. Dabei wird das Spielerobjekt durch die Tasten "a" und "d" oder die Pfeiltasten bewegt. Der Code dafür sieht folgendermaßen aus:

![Spielerbewegung1](https://user-images.githubusercontent.com/88385813/144760564-31d73119-d1c4-4170-a55e-da9519b49389.png)

Der Spieler bewegt sich hierdruch mit der definierten Geschwindigkeit nach links und rechts und wird in die Bewegungsrichtung gedreht:

![Bewegung1Gif](https://user-images.githubusercontent.com/88385813/144760740-7ab6db9d-8e39-4979-8269-d4f983ed6fd5.gif)

Zuletzt haben wir Ihnen unsere ersten Fortschritte mit Snap! präsentiert. 

### Mittwoch, 01.09.2021 <a name="acht"></a>

In dieser Stunde haben wir uns vor allem mit der grafischen Präsentation unseres Spiels beschäftigt. Zum Erstellen unserer Sprites verwenden wir [*Piskel*](#Methoden). Wir haben dabei einen Hintergrund für unser Spiel erstellt, auf dem sich der Spieler dann bewegen soll:

![Level 1 Stage 0](https://user-images.githubusercontent.com/88385813/144760922-3f4965d7-0519-45fa-84ad-88ef2089e86d.png)

Wir haben uns entschlossen einen Pixel Art-Stil für unser Spiel zu verwenden, denn die einzelnen Sprites können dann relativ schnell erstellt werden und müssen nicht besonders realistisch aussehen. So wird der Schaffungsprozess für uns auf Dauer gesehen leichter, da nicht jeder Sprite unglaublich aufwendig ist und auch leicht im Nachhinein verändert werden kann.

### Dienstag, 07.09.2021 <a name="neun"></a>

ToDo-Liste für diese Woche:
- [x] *Sprung einbauen*
- [ ] *Gravitation implementieren*
- [ ] *Groundcheck implementeiren*

Zunächst haben wir die Sprungfunktion für den Spieler eingebaut. Dies funktioniert sehr ähnlich zu der Bewegung des Spielers von zuvor. Der Spieler wird nach Drücken der "Leertaste" um 70 Einheiten auf der Y-Achse nach oben versetzt, so wirkt es als würde der Spieler springen.

![Sprung1 0](https://user-images.githubusercontent.com/88385813/144882524-a09de627-4133-4786-98de-fb109c473952.png)

Dann haben wir begonnen die Gravitation zu implementieren, damit der Spieler im Anschluss an das Springen auch wieder auf den Boden fällt. Wir haben dabei zunächst überlegt, ob wir eine gleichmäßige Fallgeschwindigkeit oder eine der Realität angepassten quadratischen Beschleunigung beim Fallen einführen wollen. Nach einigem Testen hat sich unserer Meinung nach eine quadratische Beschleunigung beim Spielen am besten angefühlt, daher werden wir diese nächste Stunde fertig implementeieren.

### Mittwoch, 08.09.2021 <a name="zehn"></a>
Für heute bleiben von der letzten Stunde noch folgende Aufgaben:
- [x] *Gravitation implementieren*
- [x] *Groundcheck implementeiren*

Die Gravitation hatten wir letzte Stunde schon fast vollständig integriert, wir haben nur noch eine angemessene Beschleunigung ausgetestet und in die Variablen für eingestezt. Letzendlich sind wir zu diesem Code gekommen:

![Sprung2 0](https://user-images.githubusercontent.com/88385813/144883822-df01bdc7-e4f5-4612-ac39-b83c5472582a.png)

Die Beschleunigung ist nun nicht ganz quadrarisch, fühlt sich aber am besten an.  
Nun haben wir noch das Fallen des Spielers gestoppt, nachdem er den Boden berührt. Dafür haben wir per Farberkennung des Bodens einen Groundcheck implementiert. Dieser guckt, ob die Spieler Sprite die Frabe braun des Bodens berührt. Falls dies der Fall ist, löst sie den Sprungscript aus, damit der Spieler wieder springen kann und das Fallen gestoppt wird. Zudem wird die Fallgeschwindigkeit wieder zum Startwert resettet:

![Sprung  3 0](https://user-images.githubusercontent.com/88385813/144886212-11ecd20e-e3f2-4760-a628-286c5580f2d4.png)

### Dienstag, 14.09.2021 <a name="Ausfall1"></a>
Da die Stunden leider ausfielen, haben wir Zuhause weitere Hintergünde designed und bei Snap! eingefügt. Es gibt jetzt zwei weitere Hintergründe - diese müssen allerdings noch begehbar gemacht werden. Der Spieler kann bis jetzt noch nicht zwischen den "Stages", also den Hintergründen, wechseln:

<img src="https://user-images.githubusercontent.com/88385813/144886868-486b8f5b-f743-4509-a676-e5d02ab053e7.png" alt="Stage1" width="45%" height="45%"> <img src="https://user-images.githubusercontent.com/88385813/144886874-15f83cc0-32d2-48ab-bb30-fa5136a3981a.png" alt="Stage2" width="45%" height="45%">



### Mittwoch, 15.09.2021 <a name="Ausfall2"></a>
Auch diese Stunde fiel leider aus. Wir wollten trotzdem beginnen, den Übergang des Spielers zwischen den "Stages" zu ermöglichen. Dabei haben wir die x-Koordinate des Spielers ausgelesen und wenn diese einen gewissen Wert übersteigt, der Spieler also aus dem Bildschirm läuft, wird der Hintergund entsprechend geändert. Die Hintergrundsänderung speichert dabei den aktuellen Hintergrund in einer Variable, um je nach aktuellem Hintergrund auf den richtigen neuen Hintergrund zu wechseln.
Dafür einerseites den Code im Spielerobjekt:

![Bildschirmfoto 2021-10-26 um 15 11 50 1](https://user-images.githubusercontent.com/88385813/144895099-f2d0581d-249e-4ceb-bb81-868ce9a64f50.jpg)
![Bildschirmfoto 2021-10-26 um 15 11 29](https://user-images.githubusercontent.com/88385813/144894903-e9052081-dd3a-4431-8e2d-ddce3c6b0cc0.jpg)


Und den Code im Stage Objekt:

![Bildschirmfoto 2021-10-26 um 15 28 01](https://user-images.githubusercontent.com/88385813/144895136-bece641b-95ad-4e9b-b37c-96064a6b1c47.jpg)
![Bildschirmfoto 2021-10-26 um 15 28 38](https://user-images.githubusercontent.com/88385813/144895147-d385195c-caa1-4d67-a0e4-117f18985ccc.jpg)


Für beide gibt es noch den Code für den linken Rand, der nach dem gleichem Prinzip funktioniert.

### Dienstag, 21.09.2021 <a name="elf"></a>
In der heutigen Stunde hatten wir mit einem Problem zu kämpfen:
Je mehr Code-Bausteine wir in unser Projekt einfügen, desto langsamer läuft das Spiel im Gesamten. Nach einigen Tests mit einem neunen Snap! Projekt zum Performancevergleich und einem Gespräch mit Ihnen konnten wir zwei Hauptprobleme indentifizieren: 
1. Die immer aktiven "When" Funktionen fressen sehr viel Performance, besser eignen sich die Broadcast Funktionen, da diese nicht immer aktiv sind und daher nicht jedes mal überprüft werden müssen, wird viel performance eingespart. Wir ersetzen jetzt also diese Funktionen:

![offeneWhenFunktion](https://user-images.githubusercontent.com/88385813/144891966-f3add09e-e7d2-4c22-ad3e-c814ecfcf418.png)

Durch diese Funktonen:

![BroadcastFunktion](https://user-images.githubusercontent.com/88385813/144892034-33ae0c8f-11dd-4ffe-a186-da7ce775b48e.png)

2. Auch das Erkennen der berührten Farbe zur Bodenerkennung (Groundcheck) frisst sehr viel Leistung. Auch hier müssen wir wohl in Zukunft eine andere Lösung finden.

### Mittwoch, 22.09.2021 <a name="zwölf"></a>
In der heutigen Stunde haben wir zunächst unser GitHub Repository überarbeitet. Dabei haben wir das Inhaltsverzeichnis für die Protokolle eingefügt, dafür haben wir mit HTML ein Dropdown eingefügt und in diesem Dropdown eine Tabelle mit den links zu den einzelnen Einträgen, der Code dafür sieht folgendermaßen aus:
```html   
<details>
<summary>Übersicht: Alle Einträge</summary>
<br>
 <table>
  <tr>
    <td><a href=#eins>Dienstag, 3. August</a></td>
    <td><a href=#zwei>Mittwoch, 4. August</a></td>
    <td><a href=#drei>Dienstag, 10. August</a></td>
    <td><a href=#vier>Mittwoch, 11. August</a></td>
    <td><a href=#fünf>Dienstag, 24. August</a></td>
  </tr>
  <tr>
    <td><a href=#sechs>Mittwoch, 25. August</a></td>
    <td><a href=#sieben>Dienstag, 31. August</a></td>
    <td><a href=#acht>Mittwoch, 1. September</a></td>
    <td><a href=#neun>Diesntag, 7. September</a></td>
    <td><a href=#zehn>Mittwoch, 8. September</a></td>
  </tr>
  <tr>
    <td><a href=#Ausfall1>Dienstag, 14. September</a></td>
    <td><a href=#Ausfall2>Mittwoch, 15. September</a></td>
    <td><a href=#elf>Mittwoch, 21. September</a></td>
    <td><a href=#zwölf>Mittwoch, 22. September</a></td>
  </tr> 
</table>
 
</details>
```
Danach haben wir angefangen ein Lebensystem in das Spiel zu integrieren, wofür wir zunächst diese Sprites erstellt haben:

<img src="https://user-images.githubusercontent.com/88385813/144893326-da5ad3bf-1742-4e68-afc6-ae354e008e5f.png" alt="herz" width="20%" height="20%"> <img src="https://user-images.githubusercontent.com/88385813/144895264-6d28669f-fa56-46e7-b7fe-ff4ec75948a6.png" alt="halbesHerz" width="20%" height="20%"> <img src="https://user-images.githubusercontent.com/88385813/144893344-2015c6f2-b0ca-4b6f-82c8-08cb8a24c33d.png" alt="keinHerz" width="20%" height="20%">

Dabei gibt es eine Variable, die die aktuellen Leben des Spielers speichert, die Leben werden dementsprechend angepasst. Die Leben werden dann links oben auf dem Bildschirm angezeigt:
![Bildschirmfoto 2021-10-23 um 20 33 59](https://user-images.githubusercontent.com/88385813/144895323-11d8b342-e9ab-495f-af25-7acef55a02f8.jpg)

Der Code besteht dabei einerseits im Spielerobjekt mit der Erkkenung des Schaden verursachenden Objekts und dem "Broadcasten" der Information Schaden bekommen zu haben:

![Bildschirmfoto 2021-10-19 um 15 53 13](https://user-images.githubusercontent.com/88385813/144895801-1fcbdb2b-bbf6-4f5f-ad8b-55d01f1b3106.jpg)

Und andererseits im Herzobjekt, wo der Schaden in eine Anzeige umgewandelt wird:

![Bildschirmfoto 2021-10-19 um 15 52 40](https://user-images.githubusercontent.com/88385813/144895727-a2b54510-38cf-4bf8-b755-6e1feec7fd50.jpg)

### Dienstag, 28.09.2021 <a name="dreizehn"></a>
Heute haben wir den Start unseres Spiels programmiert. Zunächst haben wir einen Platzhalter eingefügt, welcher einen Start-Knopf simulieren sollte. Danach haben wir ein PNG erstellt, welches die Überschrift "Spiel Starten" aufzeigt. Dieses Startmenü soll immer dann erscheinen, wenn man das Spiel das erste Mal starten möchte und immer dann, wenn man ein Leben verloren hat:

![TitleScreen](https://user-images.githubusercontent.com/88385813/144897139-19ecba59-04f6-4647-8c8b-a1d4e6f02530.png)

Nach dem Drücken des besagten Knopfes wird das Spiel durch folgende Funktion gestartet:

![StartBildschirm](https://user-images.githubusercontent.com/88385813/144898020-f35f81fa-d1d9-4704-b24e-27cfff57086b.png)

![StartBildschirm](https://user-images.githubusercontent.com/88385813/144898037-00ee2825-a6ee-427a-a083-930aeee84b6c.png)

Anschließend haben wir uns mit einem plötzlich aufgetretenden Problem befasst. Wenn wir mit der Spielfigur auf die Lava kommen, wird zunächst wie gewollt ein halbes Leben abgezogen. Anschließend, wenn der Charakter nur noch 1,5 Leben hat, wird jedoch plötzlich ein ganzes Leben abgezogen. Um diesem Problem zu beheben, haben wir unseren Code noch einmal genau untersucht. Zunächst lag nahe, dass sich ein Fehler in dem Sprite des zweiten Lebens befindet. Hier konnten wir jedoch auch durch Veränderung des Codes und Ausprobieren keinen Fehler identifizieren. Aus diesem Grund liegt Nahe, dass sich der Fehler bei den Hauptdefinitionen der Stage befindet.

### Mittwoch, 29.09.2021 <a name="Ausfall3"></a>
Die ausgefallene Stunde haben wir genutzt, um eine Projektseite zu erstellen und die ersten Teile unseres Codes zu erklären. Außerdem haben wir nochmals vergeblich versucht das Problem mit den Herzen zu Lösen. Das Problem hierbei ist, dass die selbe Funktion zuvor funktionierte und in anderen Objekten noch immer funktioniert. 

### Dienstag, 5.10.2021 <a name="vierzehn"></a>
Zu Anfang dieser Stunde haben wir Ihnen unser Problem mit den Herzen geschildert. Nach einigem Brainstorming sind wir gemeinsam zu dem Schluss gekommen, das Herzen-System nicht mehr variabel über eine Funktion zu Steuern, sondern für jeden Zustand eine einzelne Funktion zu nutzen. Jedes Herz hat jetzt seinen Kostümen exakte Lebensanzahlen zugeordnet, der Fehler ist somit gelöst. Hier noch einmal der Vergleich.

Altes System:

![Bildschirmfoto 2021-10-19 um 15 52 40](https://user-images.githubusercontent.com/88385813/144907796-9c7753c4-030f-45ce-815d-707781331e8f.jpg)

Neues System:

![Bildschirmfoto 2021-10-19 um 15 53 00](https://user-images.githubusercontent.com/88385813/144907813-e481ef67-c85a-4b92-947b-f8c6458aa3b0.jpg)

Trotzdem verwirrt uns noch immer, warum der Fehler aufgetreten ist. Snap! scheint manchmal inkonsequent zu sein. So kann z.B. auch bei unser Bodenerkennung betrachtet werden, dass der Spieler jedes mal unterschiedlich weit in den Boden einsackt, obwohl er gestoppt werden sollte, sobald er die braune Farbe des Bodens berührt:

![BodenBug (1)](https://user-images.githubusercontent.com/88385813/144908763-a460b158-da62-4a4d-af94-d7c1f493a0e6.gif)


Auch für dieses Problem müssen wir noch eine Lösung finden, zumal auch das Erkennen der Farben aufgrund der hohen Performance-Einbußen noch geändert werden muss, dafür war diese Stunde aber keine Zeit mehr.

### Mittwoch, 6.10.2021 <a name="fünfzehn"></a>
Für die heutige Stunde haben wir uns folgendes vorgenommen:
- [x] *Groundcheck verändern*
- [x] *Problem der Inkonsequenz beim landen des Spielers lösen*

Zuerst haben wir dabei verändert, wie das Spielerobjekt festellt, ob es den Boden berührt. Wir haben nun eine Linie eingefügt, die an der oberen Kante des Bodens verläuft. Berührt der Spieler nun diese, so berührt er den Boden. Wir mussten nun noch das Einsinken des Spielers in den Boden verhindern. Zuerst dachten wir, dass dies durch die neue Bodenerkennung vielleicht automatisch besser werden würde, da die Performance dadurch enorm verbessert wurde, doch das Problem blieb bestehen. Dabei war das größte Problem daran, dass der Spieler somit immer unterscheidlich hoch springen würde, da er vor dem Sprung höher oder tiefer im Level sein würde. So würden aber präzise Sprünge niemals funktionieren. Deshalb setzten wir den Spieler nun immer auf eine vordefinierte Höhe, sobald er die Bodenlinie berührt. Außerdem  stirbt der Spieler nun, wenn er in ein Loch fällt. Die Codeveränderungen von heute sehen folgendermaßen aus:

![Screenshot 2021-12-06 203213](https://user-images.githubusercontent.com/88385813/144910265-2bbba7f7-cc14-4aa9-bdf7-78b8e5b46339.png)

Und so sieht das BodenHitboxObjekt aus:

![Screenshot 2021-12-06 203306](https://user-images.githubusercontent.com/88385813/144910326-5f563b5f-54e5-4182-84be-b465b92722e7.png)


### Dienstag, 12.10.2021 <a name="sechzehn"></a>

Da die Bewegung des Spielers seit der letzten Stunde nun gut funktioniert und wieder eine gute Performance aufweißt, wollten wir heute ein Spielmenü für unser Spiel erstellen. Wir haben dabei ein paar Inhalte für das Menü vordefiniert:

- [x] *Charachter Wechseln Menü*
- [x] *Spiel Starten Knopf*
- [ ] *Anleitung Menü*

Das Menü soll dabei vor allen Dingen leicht und intuitiv mit der Maus durch Klicken bedient werden können. Dafür haben wir uns überlegt, unsichtbare Knopfobjekte über die Bilder des Menüs im Stageobjekt zu legen und beim Klicken dieser jeweils den Hintergrund zu wechseln. Dabei wollten wir auch "Highlighten", wenn die Maus über einem Objekt schwebt, damit man weiß, welche objekte anzuklicken sind. Hier als Beispiel einmal der Zurückknopf des Charackterauswahlscreens:

![highlightMenü](https://user-images.githubusercontent.com/88385813/144913647-74679718-fda5-4a94-91d6-19bc0cd68e6f.gif)

So wollen wir auch die anderen Menüelemente umsetzten, denn so kann man unserer Meinung nach klar erkennen, wie das Menü bedient werden soll.

Für das Charaktermenü haben wir noch weitere Sprites für unseren Spieler angefertigt, welche sich lediglich in der Frabe, nicht aber in der Form unterscheiden, damit das Spiel weiterhin mit allen Spielern funktioniert.

### Mittwoch, 13.10.2021 <a name="siebzehn"></a>
Heute wollten wir eine Schranke einbauen, welche die Spielfigur passieren muss, um nicht in der Lava zu sterben. 
Dafür haben wir bei Piskel eine provisorische Schranke erstellt, welche wir anschließend programmieren wollten. 
Wir sind nach einigem Probieren zu dem Entschluss gekommen, dass wir die Schranke durch einen Knopf ersetzen wollen. Dies ist nach unserer Bewertung anschaulicher, da es sich um ein 2D Projekt und nicht um ein 3D Projekt handelt.
Unsere Vorstellung ist das, wenn sich der Charakter auf dem Knopf befindet, die Lava erschwinden und der Charakter kann weiter in Richtung des Ziels laufen. Dabei war das Hauptptoblem, dass wenn die Figur auf den Knopf befindet, die Lava immer schnell hintereinander verschwindet und wiederkommt. Das ist logischerweise auf den Befehl "when touching "Knopf"" zurückzuführen, bei dem dieser Befehl immer wieder schnell hintereinander ausgeführt wird. 
Um dieses Problem zu entgehen, haben wir den Code dahingehend erweitert, dass das Verschwinden und Wiedererscheinen der Lava nur mit einem zeitlichen Abstand von einer Sekunde passiert. Diese gewählte Zeit ist vor allem deshalb gut, weil somit zwar direkt beim Berühren des Knopfes die Lava verschwindet, sie jedoch nicht hin und her springt (nur wenn man auf dem Knopf stehen bleibt nach einer Sekunde) Verlässt der Charakter den Knopf und berührt anschließend wieder den Knopf ist eine Sekunde ebenfalls vergangen und er Befehl kann ohne Zeitverzug ausgeführt werden. 
Zuhause haben wir versucht, den Hintergrund zu animieren. Dafür haben wir eingestellt, an welcher Stelle die Wolken im Hintergrund erscheinen sollen uns mit welcher Geschwindigkeit sie sich anschließend in welche Richtung bewegen sollen. 
Schlussendlich haben wir die Idee wieder verworfen, da die Lava permanent aktiv sein soll, wir haben aber durch den Schalter die Idee für ein Tor bekommen, dass wir vielleicht später einfügen wollen.
### Dienstag, 19.10.2021 <a name="achtzehn"></a>
Wir haben heute das Gesamtlevel-Layout zusammengestellt und uns überlegt, was auf welcher Stage zu sehen oder zu tun sein soll. Insgesamt soll es 6 Stages geben. Eine soll einen Schlüssel und ein Loch beinhalten und befindet sich ganz links. Rechts daneben soll ein Wald platziert werden. Daneben die erste Stage, in der das Spiel beginnt. Der Spieler soll hier das Hindernis Lava überwinden müssen. Wir haben bereits für den Schaden eine Art Lava erstellt, diese haben wir nun angepasst, so dass sie funktioniert. Die nächste Stage soll das Tor beinhalten, der Spieler soll dieses nur mit Schlüssel öfnnen können. Daneben sol eine Art Boss Raum erstellt werden. wie dieser Boss genau aussieht wissen wir noch nicht. Zuletzt soll das Ziel auf der Stage ganz rechts angezeigt werden.

Zusätzlich haben wir noch das Lochobjekt für die erste Stage erstellt, wenn der Spieler dieses berührt, so fällt er durch die BodenHitbox hindurch und stirbt:

![Screenshot 2021-12-06 203306](https://user-images.githubusercontent.com/88385813/144916256-726d2b6f-db77-4e9f-9ed7-b77a1e78afe1.png)

Um alle diese Stages einfacher miteinander zu verbinden wollen wir in der nächsten Stunde das komplette Stagewechseln neu programmieren. Vor allen Dingen das Erkennen, ob der Spieler sich am Rand befindet soll anders gelöst werden, da das alte Prinzip mit der x-Koordinate nicht zuverlässig funktioniert und viel Performance frisst. Dafür haben wir bereits zwei Linien an jeden Rand paltziert, damit der Spieler bei Kontakt mit diesen in die nächste Stage wechselt.

### Mittwoch, 20.10.2021 <a name="neunzehn"></a>
Heute begann die große Aufgabe das Stagemanagement neu zu programmieren. Die Abfrage welche Stage gerade geladen ist funktioniert nun nicht mehr umständlich über eine Variable, wie zuvor, sondern über den Kostümnamen der Stage. So weiß das Stageobjekt immer wenn der Spieler eines der Randobjekte berührt und weiter in Richtung dieses Rands läuft, auf welche Stage nun gewechslet werden muss und an welchen Rand der Spieler nun platziert werden muss.

Code eines Randobjekts:

![Screenshot 2021-12-06 212610](https://user-images.githubusercontent.com/88385813/144917464-75df00e2-f103-4f00-bfa5-9d6a1ed93b65.png)

Umsetzung der Broadcasts im Stageobjekt:

![Screenshot 2021-12-06 212549](https://user-images.githubusercontent.com/88385813/144917401-e02e70f6-7510-4e33-806b-8a6a3ac89de1.png)

Bei der implementierung des neuen Systems war uns vor allen Dingen die nachträgliche Erweiterung dieses Managers um weitere Stages wichtig, da wir in den nächsten Stunden nach und nach alle Stages einfügen wollten. Außerdem mussten wir auch für das erscheinen von Objekten in bestimmten Stages, wie z.B. das Loch und die Lava ein genaus "Broadcasting" System haben, dass die Objekte anzeigt und beim verlassen der Stage wieder versteckt. In der Stunde wurden wir leider nicht ganz fertig, aber am Wochenende stellten wir den Manager fertig.

Der neue Manager funktioniert nun viel besser und kann leicht erweitert werden, da er die Speicherung der aktuellen Stage durch Variablen losgeworden ist.

### Dienstag, 26.10.2021 <a name="zwanzig"></a>

Einfügen von hintergrundobjekten nur auf bestimmten stages
und wolken, die sich bewegen
=> alles soll lebendiger sein


### Mittwoch, 27.10.2021 <a name="einundzwanzig"></a>

Überlegung Musik Stücke, warum wollen wir musik , welche Stücke soll es geben

laser Idee erste umsetzunbg

### Dienstag, 2.11.2021 <a name="zweiundzwanzig"></a>
einfügen von game over screen, nach menü prinzip
higlight schnelle rückkehr zum spiel 
auch victory screen
=> spiel soll endlich durchzuspielen sein
### Mittwoch, 3.11.2021 <a name="dreiundzwanzig"></a>

### Dienstag, 9.11.2021 <a name="Ausfall4"></a>
Diese Stunde fiel leider aufgrund einer Klausur aus. Mit den anstehenden Klausuren im Kopf haben wir Zuhause diesmal nicht an unserem Projekt gearbeitet, sondern die Zeit zur Vorbereitung genutzt.

### Mittwoch, 10.11.2021 <a name="vierundzwanzig"></a>
Einfügen der Musik, Problem mit Loop und speicherplatz in Snap!
### Dienstag, 16.11.2021 <a name="füfnundzwanzig"></a>
Schlüssel und Tor, Gedanke an Rätsel
### Mittwoch, 17.11.2021 <a name="sechsundzwanzig"></a>
Timer, Spieler soll versuchen eine bessere zeit bei jedem versuch zu bekommen und Laser aufgrund von Hit Erkennungsproblemen durch speere ersetzten, (außerdem passen Speere besser zum Thema)
### Dienstag, 23.11.2021 <a name="siebenundzwanzig"></a>
zuletzt Anleitungseiten anfertigen, Spieltesten mit anderen leuten, ist das Spiel für jemanden framden schlüssig, gibt es bugs (zuhause)
### Mittwoch, 24.11.2021 <a name="achtundzwanzig"></a>

### Dienstag, 30.11.2021 <a name="neunundzwanzig"></a>
Vor allem haben wir heute die Dokumentierung des Projekts vervollständigt. Dabei haben wir unsere Notizen zu den Stunden in erste GitHub-Einträge umgewandelt. Außerdem wurdedn noch die in der letzten Stunde programmierten Speere in zwei Wellen eingeteilt. So ist es schwieriger das Hindernis zu umgehen, da erst die eine Hälfte der Speere fällt und anschließend die andere. Der Spieler kann nun nicht mehr nur abwarten und nach dem fallen der Speeren beim respawnen dieser zum Ziel laufen. 

Das ganze ist durch eine einfache "wait" Funktion umgestezt, nachdem die Stage mit den Speeren betreten wurde.

Speer der direkt losfliegt:

![Screenshot 2021-12-06 214818](https://user-images.githubusercontent.com/88385813/144920218-1a52de28-29d7-4e31-99b0-1fa0d62fb298.png)

Speer, der später losfliegt:

![Screenshot 2021-12-06 214730](https://user-images.githubusercontent.com/88385813/144920135-122ea314-58f1-47e3-8263-aebfeedb2963.png)

Generell war uns in den letzten Stunden wichtig dem Spiel zu mindest in gewissem Maße eine Schwierigkeit zu verleihen. Das ist uns durch diverse Änderung an der Lava und auch den Speeren unserer Meinung gelungen.

### Mittwoch, 1.12.2021 <a name="dreißig"></a>
Jannik war leider heute krank, da wir aber schon seit der letzten Stunde nur noch an Fehlerbehebungen im Code und hauptsächlich der Dokumentierung auf der Projektseite gearbeitet hatten und das Snap! Projekt eigentlich fertig war, arbeitete Thorge an den Fehlerbehebungen und der Codeerklärung weiter. 

Dabei gab es einen Fehler, bei dem der Schlüssel auch auf einer Stage aufgehoben werden konnte, auf der er nicht zu sehen war. Der fehler war allerdings schnell durch eine Kopplung des Aufhebebefehls an das aktiv sein der Schlüssel-Stage. Nun kann der Schlüssel nur noch in der linken Stage aufgehoben werden. 

Auch am generellen Layout der Blog.Seite wurde weitergearbeitet. Hier wurde eine Refelxion des Endprodukts und einige Quellen hinzugefügt. 
Außerdem wurden alle Überschriften im Blog mit passenden Emojis versehen:

![Screenshot 2021-12-06 213908](https://user-images.githubusercontent.com/88385813/144919202-c2ca6249-a1f2-444b-b6c0-751ff9062d9e.png)
![Screenshot 2021-12-06 213938](https://user-images.githubusercontent.com/88385813/144919212-913956c6-ac10-4123-8b66-47c801d81d38.png)

## 🔧Arbeitsmethoden<a name="Methoden"></a>

### 🎨Sprite Erstellung<a name="MethodenSprite"></a>

Für unser Projekt wollten wir einen Pixel-Art Stil umsetzten. Dafür mussten wir natürlich einige Sprites erstellen, um den verscheidenen Objekten in unserem Spiel Aussehen und Leben zu verleihen. Wir haben hierfür das Online-Programm  [*Piskel*](https://www.piskelapp.com/) verwendet.
                                           
![piskelLogo](https://user-images.githubusercontent.com/88385813/144750564-be75f0cb-ea5b-4c10-86c0-ee2195c0886d.jpg)
                                       

Hier haben wir die meisten unserer Sprites selbst erstellt und anschließend als PNG exportiert und in unser Snap!-Projekt geladen. Ein Beispiel für die Sprite Bearbeitung kann anhand der Erstellung der Spielfigur nachvollzogen werden:

![PiskelScreen](https://user-images.githubusercontent.com/88385813/144751074-ea7ffee1-a388-4f68-b9a5-de05ee812e6c.png)

Im anschluss an das erstellen der Spielfigur in Piskel konnten wir leicht durch die Tools von Piskel die zwei anderen Farbvarianten der Spielfigur erstellen:
 
![RoterAbenteurer (1)](https://user-images.githubusercontent.com/88385813/144751151-8899d67c-8d7e-4794-9f22-f5348b2e61d4.png)
![GrünerAbenteurer (1)](https://user-images.githubusercontent.com/88385813/144751153-d56796fc-1eff-47ad-ac64-1d9205fcfdc1.png)
![BlauerAbenteurer (2)](https://user-images.githubusercontent.com/88385813/144751160-8338394d-2070-4b56-8ee0-3b65d205a454.png)

Dabei muss noch erwähnt werden, dass einige Sprites nicht von uns ersetllt wurden. Dabei handelt es sich konkret um die Schlüssel-Sprite, die Tor-Sprite und die unterschiedlichen Stein-Sprites. Die Quellen für diese Sprites finden sich [*hier*](#Quellen).


### 🎵Komponieren der Musik
 
Musik verleiht Bildern eine eindrucksvollere Wirkung.
Bei unserem Spiel hat die Musik aus diesem Grund eine sehr wichtige Rolle.
Damit die Musik mit den Bildern übereinstimmt, haben wir uns überlegt nicht einfach einen bereits bestehenden Song zu verwenden: Wir haben jede Musik in unserem Spiel selbst komponiert.
Bis zum letzen Jahr haben wir Musik als Kurs in der Schule belegt. Wir haben für die Erstellung dieser Musikstücke unsere Erkenntnise aus dem Unterricht verwendet.
Somit war es uns ermöglicht, die erlernten theoretischen Kenntnisse in praktische Resultate umzuwandeln.
Die Musik für das Spiel haben wir mithilfe von [*GarageBand*](https://www.apple.com/de/ios/garageband/) komponiert, dabei war uns vor allen Dinegn wichtig, für alle Szenarien, also Menü, In Game, Game Over und Victory Screen eine passende Musik zu entwickeln. 
Aus diesem Grund haben wir vier Stücke erstellt:
 
#### Die Menü-Musik (Titelmusik)

Dieses Stück ist das Kernstück unserer Komponisationen. Es handelt sich um ein Stück in G-Dur. 
Wir haben uns für ein Stück in Dur entschieden, weil die Titelmusik einen freundlichen und fröhlichen Eindruck erwecken soll und der Spieler sich motiviert fühlen sollte, dass Spiel nun zu starten.
In diesem Stück werden die Akkorde durch das Instrument 80s Sine Synth gespielt. Es handelt sich dabei um jeweils Viertel, welche immer wieder durch Viertelpausen unterbrochen werden. Die Akkorde stellen eine Abfolge von C-Dur/F-Dur/C-Dur/G-Dur dar. Dabei werden die Akkorde in der Tiefe durch den Liverpool Bass unterstützt.
Hier haben wir mit dem Equalizier noch etwas die Tiefen verändert, damit diese noch ein bisschen stärken zum Vorschein kommen. 
 <img width="864" alt="Bildschirmfoto 2021-12-05 um 19 21 53" src="https://user-images.githubusercontent.com/88385954/144758629-36e8926d-1d2c-4aa5-ae0b-38c884e09b1b.png">

Die höhen haben wir stattdessen etwas rausgenommen, da dieser Frequenzbereich bereits durch das Instrument "Cheap Organ" abgedeckt wird. 
Der Liverpool Bass und Cheap Organ spielen die gleiche Begleitung, unterscheiden sich etwas in ihrem Sound, jedoch deutlich in ihrer Frequenz.
After Party stellt ein Drum Kit da, bei welchem wir uns für die HiHat bedient haben. 
Das Warm Synth Pad ist ein Streicher-Ensemble welches den Klang durch die damit erlangte "Wärme" unterstützt.
Das Herzstück diesen Stückes ist die Flöte. Sie spielt über allen anderen Instrumenten die Höhen.

Um den Aufbau des Stückes noch etwas deutlicher zu machen, haben wir uns überlegt, ein Video aufzunehmen, bei welchem wir Ihnen die "Entstehung" des finalen Stückes durch das langsame hinzukommen der verschiedenen Instrumente zeigen.

https://user-images.githubusercontent.com/88385813/144753988-c8a7f50e-673c-42f9-9b3d-7fb8c9ddd7a2.mp4

Wir haben eine Notation der einzelnen Instrumente erstellt, damit man den Aufbau und das Zusammenspielen der verschiedenen Instrumente leichter nachvollziehen kann.
 
![Titelmusik - Notation](https://user-images.githubusercontent.com/88385813/144754125-76b8bd5f-4c2f-494d-afb7-f515051a94da.png)

Dieses Stück eröffnet das Spiel und ist damit das erste, was der Spieler zu hören bekommt. Wir wollen mit dieser Musik den fröhlichen und abenteuerlichen Charakter unseres Spiels unterstreichen, dabei soll der Klang an das gefühl erinnern, dass einen bei einem schönen Sommerspaziergang in einer interessanten Landschaft erfüllt: So beginnt auch unser Spiel.

#### In Game-Musik
 
Die In Game-Musik ist schlicht aufgebaut. Sie besteht aus zwei Instrumenten. Zum einen das Drum-Kit Brooklyn und aus dem Liverpool Bass.
Mit dem Brooklyn Drum-Kit wird durch die HiHat ein eingängiger Rhythmus erzeugt.
Der Liverpool Bass spielt die Abfolge von einem tiefen Ton und dem gleichen Ton eine Oktave höher.
Die verwendeten Töne bzw. Oktaven sind C, H und A. Eine gewisse Spannung wird erzeugt, indem beim zweiten Durchlauf die Töne D,C und H verwendet werden, alles somit um einen Ton nach oben verrückt ist.

Das Ziel diesen Stückes ist es, während des Spiels eine Begleitmusik zu haben, welche immer schneller wird und somit den Zeitdruck auf den Spieler erhöht bzw. unterstreicht. Dafür muss das komponierte Stück vor allem kurz und spannungserzeugend sein.

Mit dem folgenden Video lässt sich der Aufbau noch einmal genauer nachvollziehen:


https://user-images.githubusercontent.com/88385813/144872613-e03be9aa-656d-47bb-aaff-d541f9251944.mp4


Notation der Musik:
 
![In Game Musik Notation](https://user-images.githubusercontent.com/88385813/144757306-a2d23939-0b51-454e-8c06-caa555383593.png)

Bei diesem Stück ging es uns vor allem Dingen darum, die Ablaufende Zeit auch akustisch zu repräsentieren, daher ist das Motiv sehr simpel gehalten, wird aber mit der Zeit immer schneller. Der Spieler wird so ein wenig unter Druck gestezt, kriegt aber auch passiv mit, wann die zeit ausläuft.
 
#### Victory Screen-Musik

Die You-Win Musik soll vor allem eines sein: fröhlich. Aus diesem Grund ist auch diesen Stück in Dur geschrieben, es handelt sich um C-Dur.
Die Grundakkorde werden von dem Classic electric piano gespielt. Die Grundakkorde ähneln den Akkorden, welche bereits bei der Titelmusik verwendet wurden. 
<img width="1084" alt="Bildschirmfoto 2021-12-05 um 21 16 17" src="https://user-images.githubusercontent.com/88385954/144762402-96c953ed-2e91-447b-95e9-639407917182.png">
 
Dies haben wir bewusst gewählt, weil nach dem You-Win Screen Display direkt wieder das Menü mit der Titelmusik erscheint. Mit den gleichen Akkorden lässt sich ein flüssiger Übergang kreieren.
Die Akkorde werden durch den Liverpool Bass unterstützt.
Eine kleine eigene Melodie spielt das Steinway Grand Piano. Damit soll ein leichter Kontrast zur Hauptmelodie geschaffen werden.
Das Brooklyn Drum Set erzeugt durch die HiHat einen passenden Hintergrundrhytmus.
Das Glockenspiel Marimba spielt die zweite Stimme der Melodie. Hier besteht die Besonderheit, dass wir nachdem Einspielen der Melodie die Tonlänge am Computer angepasst haben. Anders als bei der Titelmusik ist jeder Ton somit gleich lang. Dies soll nach dem Spiel die Zufriedenheit des Spielers verstärken.
Die erste Stimme übernimmt das Ensemble aus drei Geigen.

Der entsprechende Aufbau des Stückes:

https://user-images.githubusercontent.com/88385813/144754402-167bd1ed-a51b-4d68-b692-f45adab3fa07.mp4

Notation der Musik:

![YouWinNotation](https://user-images.githubusercontent.com/88385813/144754459-2bc865da-dde2-4d7d-aacc-ae6970e1ff87.png)

Bei diesem Stück war uns wichtig, einen kurzen, aber belohnenden Übergang von der In Game-Musik zur Menü-Musik zu schafen. Das ganze ist an einen tusch angelehnt und damit sehr kurz und prägnant. Unser Ziel war, dass man auch ohne etwas zu sehen, feststellen kann, dass das Spiel gewonnen wurde.
 
#### Game Over-Musik

Im Gegensatz zu den anderen Stücken soll die Game Over Musik eine negative, traurige Stimmung erzeugen. Aus diesem Grund ist die Game Over Musik in Moll geschrieben. 
Es handelt sich um F-Moll.
Das Classic Electric Piano erzeugt die absteigenden Grundakkorde. Dabei handelt es sich um C-Moll, G-Moll und F-Moll. Das Herabsteigen der Akkorde stellt einen Kontrast zu den anderen Stücken da, bei denen die Akkorde steht´s nach oben gespielt wurden. 
Damit wird die destruktive Stimmung nach dem Scheitern eines Spielversuches aufgegriffen.
Die Panflöte spielt die Melodie. Auch diese ist nach unten aufbauend, genau wie die Akkorde. Bei der Flöte haben wir die Tiefen etwas erhöht, damit die sonst fröhliche Flöte einen düsteren Eindruck erweckt.
 <img width="722" alt="Bildschirmfoto 2021-12-05 um 21 17 39" src="https://user-images.githubusercontent.com/88385954/144762441-dfe31840-a7ae-4132-afd5-a7ad1cfca2de.png">

Der Liverpool Bass unterstützt die Akkorde, ebenfalls abfallend.
Das Brooklyn Drum-Kit legt durch die HiHat den Hintergrundrhytmus fest.

 
Aufbau der Musik:
 
https://user-images.githubusercontent.com/88385813/144755444-5ec7c747-fd1c-4021-8504-8af2bb82a621.mp4

Notation der Musik:

![GameOverMusikNotation](https://user-images.githubusercontent.com/88385813/144755561-ebb01197-597d-4ddf-b7d7-8bbe5799af56.png)

Dieses Stück unterstreicht das vorzeitige Ende des Abenteuers und ist dementsprechend traurig gehalten. 

## 📥Reflexion des Projekts<a name="Reflex"></a>

Zuletzt wollen wir noch unser Projekt und den Arbeitsprozess rückblickend bewerten. 
 
Insgesamt sind wir sehr zufrieden mit unserem Projekt, wir haben fast jede unserer Vorstellungen in Snap! umsetzten könne, auch wenn dies manchmal sehr kreative Lösungen erforderte. Generell hat uns die Arbeit an dem Projekt auch sehr viel Freude bereitet, denn das logische Denken und Lösen von Problemen war eine willkommene Abwechslung zum sonstigen Unterricht und hat uns auch über die Schulstunden hinaus gut beschäftigt.  
Mit unserem Arbeitsprozess sind wir auch sehr zufrieden, wir haben in den Stunden fast immer erreicht, was wir uns vorgenommen hatten und haben uns die gesamte Zeit gut eingeteilt. Wir hatten also einen gut über die Gesamtzeit verteilten Arbeitsaufwand und mussten lediglich zuletzt unsere Notizen zu den Stunden noch in Protokolleinträge in unserem GitHub Repository verwandeln. Auch die Arbeitsteilung zwischen uns beiden hat sehr gut funktioniert. Nach kurzer Einarbeitungszeit konnten wir beide am Spiel programmieren. Durch die Cloud-Funktion von Snap! konnten wir beide Zuhause das Spiel weiter programmieren und der jeweils andere konnte die Änderungen aus der Cloud herunterladen. Darüber hinaus hat Thorge sich zum größten Teil um die Erstellung der Sprites gekümmert, während Jannik den großteil der Musikproduktion übernahm. Somit konnten wir beide unsere Schwächen ausgleichen und im Endeffekt ein rundes Endprodukt mit Musik und Sprites erstellen.  
Für unsere GitHub Seite hatten wir die Arbeit grob in [Projektseite]() und [Protokollseite](https://github.com/ThorgeHamprecht/Informatik-Projekt-Nr.-1/blob/main/README.md) unterteilt, da beides ungefähr gleich viel Arbeit gemacht hat. Natürlich haben wir trotzdem Beide an beiden Seiten gearbeitet.

Das Snap! Projekt ist am Ende unserer Vorstellung entsprechend geworden. Natürlich gab es einige Schwierigkeiten mit Snap! und der Performance von Snap!, aber letzendlich konnte das Projekt so wie von uns geplant auch umgesetzt werden. Vor allen Dingen das Menü und die Musikstück-Implementierung gefallen uns dabei gut, da sie einwandfrei und nachvollziehbar funktionieren. Probleme gab es vor allen Dingen mit der Boden Erkennung, auch bis zuletzt ist diese nicht ganz perfekt gelöst, allerdings ist dies vor allem den besonderen Gegebenheiten in der Programmierumgebung Snap! geschuldet.
 
Abschließend lässt sich festhalten , dass wir sehr zufrieden mit unserem Projekt sind. Für unser nächstes Projekt wollen wir allerdings nicht mit Snap! arbeiten, um erstens etwas neues kennenzulernen und zweitens nicht nocheimal mit den Limitationen von Snap! arbeiten zu müssen. Wir freuen uns daher schon auf unser zweites projekt und hoffen, dass wir wieder so viel lernen und so viel Spaß haben wie dieses Mal. 

## ℹ️Quellen<a name="Quellen"></a>
### Quellen für GitHub
1. [Markdown - Befehlübersicht](https://markdown.de/)
2. [HTML - Basics](https://www.w3schools.com/html/html_basic.asp)
3. [HTML - Tabellen](https://wiki.selfhtml.org/wiki/HTML/Tabellen/Aufbau_einer_Tabelle)
4. [HTML - Dropdowns](https://wiki.selfhtml.org/wiki/HTML/Tutorials/Navigation/Dropdown-Men%C3%BC)
### Quellen für Sprites
1. [Sprite - Steine](https://www.artstation.com/artwork/8eLdrE)
2. [Sprite - Schlüssel](http://pixelartmaker.com/art/701d599ee087f38)
3. [Sprite - Tor](https://www.deviantart.com/nicnubill/art/castle-Gate-428853290)




---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
